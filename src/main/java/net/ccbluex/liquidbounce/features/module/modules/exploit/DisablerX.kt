package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.ModuleManager
import net.ccbluex.liquidbounce.features.module.modules.exploit.disabler.Hypixel
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.features.module.modules.movement.TargetStrafe
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.NotifyType
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacketNoEvent
import net.ccbluex.liquidbounce.utils.TimeHelper
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.client.gui.inventory.GuiInventory
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.util.MathHelper
import java.util.*
import java.util.concurrent.CopyOnWriteArrayList
import kotlin.math.pow
import kotlin.math.roundToInt
import kotlin.math.sqrt


@ModuleInfo(name = "DisablerX", category = ModuleCategory.EXPLOIT)
class DisablerX : Module() {
    val modeValue = ListValue(
        "Mode",
        arrayOf(
            "NewBest",
            "Basic",
            "Verus",
            "Cancel",
            "Flying",
            "Matrix",
            "Hypixel"
        ),
        "Basic"
    )
    private val debug = BoolValue("Debug", false)
    val timerValue = BoolValue("HypixelTimer", false)
    private val memeAACValue = BoolValue("MatrixWithAAC5", false).displayable { modeValue.equals("Matrix") }
    private val verusSlientFlagApplyValue =
        BoolValue("VerusSlientFlagApply", false).displayable { modeValue.equals("Verus") }
    private val verusBufferSizeValue =
        IntegerValue("VerusBufferSize", 300, 0, 1000).displayable { modeValue.equals("Verus") }
    private val verusFlagDelayValue =
        IntegerValue("VerusFlagDelay", 40, 35, 60).displayable { modeValue.equals("Verus") }
    private val verusRepeatTimesValue =
        IntegerValue("Verus-RepeatTimes", 1, 1, 5).displayable { modeValue.equals("Verus") }
    private val verusRepeatTimesFightingValue = IntegerValue(
        "Verus-RepeatTimesFighting",
        1,
        1,
        5
    ).displayable { modeValue.equals("Verus") }

    private var verus2Stat = false
    private var packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private var currentTrans = 0
    private var memeTick = 0
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()

    private var counter = 0
    private var x = 0.0
    private var y = 0.0
    private var z = 0.0
    private var expectedSetback = false

    private var modified = false

    private var hasDisabled = false
    private val clickWindowPackets = CopyOnWriteArrayList<C0EPacketClickWindow>()
    private var isCraftingItem = false
    private var timedOutTimer = TimeHelper()
    private var lastUid = 0
    private var cancelledPackets = 0

    private val repeatTimes: Int
        get() = if (LiquidBounce.combatManager.inCombat) {
            verusRepeatTimesFightingValue.get()
        } else {
            verusRepeatTimesValue.get()
        }


    override fun onEnable() {
        if (modeValue.equals("Verus")) {
            LiquidBounce.hud.addNotification(
                Notification(
                    name,
                    "Please wait for Disabling AntiCheat...",
                    NotifyType.INFO
                )
            )
        }
        reset()
    }

    override fun onDisable() {
        modified = false
        when (modeValue.get().lowercase()) {
            "matrix" -> {
                for (packet in packetBuffer) {
                    sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "hypixel" -> {
                counter = 0
            }
        }
    }


    @EventTarget
    fun onWorld(event: WorldEvent) {
        reset()
        Hypixel.reset()
    }

    private fun reset() {
        memeTick = 0
        currentTrans = 0
        verus2Stat = false
        packetBuffer.clear()
        fakeLagDelay.reset()
        fakeLagDuration.reset()
        counter = 0
        expectedSetback = false
        hasDisabled = false
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        when (modeValue.get().lowercase()) {
            "verus" -> {
                if (fakeLagDelay.hasTimePassed(490L)) {
                    fakeLagDelay.reset()
                    if (packetBuffer.isNotEmpty()) {
                        val packet = packetBuffer.poll()
                        repeat(repeatTimes) {
                            sendPacketNoEvent(packet)
                        }
                        debugMessage("RELEASE")
                    } else {
                        debugMessage("RELEASE BUT EMPTY")
                    }
                }
            }

            "matrix" -> {
                memeTick++
                val cTick = if (memeAACValue.get()) {
                    (mc.timer.timerSpeed.toDouble().pow(2.0) * 10).roundToInt()
                } else {
                    (mc.timer.timerSpeed.toDouble().pow(2.0) * 7.6).roundToInt()
                }
                if (memeTick >= cTick) {
                    memeTick = 0
                    for (packet in packetBuffer) {
                        sendPacketNoEvent(packet)
                    }

                    debugMessage("Release buf(size=${packetBuffer.size}, cTick=$cTick)")
                    packetBuffer.clear()
                }
            }
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        val buffPacket = packet as Packet<INetHandlerPlayServer>

        when (modeValue.get().lowercase()) {
            "basic" -> {
                if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                }
            }

            "verus" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    packetBuffer.add(packet)
                    event.cancelEvent()
                    if (packetBuffer.size > verusBufferSizeValue.get()) {
                        if (!verus2Stat) {
                            verus2Stat = true
                            LiquidBounce.hud.addNotification(
                                Notification(
                                    name,
                                    "AntiCheat is disabled.",
                                    NotifyType.SUCCESS
                                )
                            )
                        }
                        val packet = packetBuffer.poll()
                        repeat(repeatTimes) {
                            sendPacketNoEvent(packet)
                        }
                    }
                    debugMessage("C0F IN ${packetBuffer.size}")
                } else if (packet is C03PacketPlayer) {
                    if ((mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0) && (mc.thePlayer.ticksExisted > verusFlagDelayValue.get() + 1) && !modified) {
                        debugMessage("C03 MODIFY")
                        modified = true
                        packet.y -= 11.4514 // 逸一时，误一世
                        packet.onGround = false
                    }
                } else if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        // why didnt they check flag apply delay? LMAO
                        debugMessage("FLAG APPLY")
                        sendPacketNoEvent(
                            C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.getYaw(),
                                packet.getPitch(),
                                true
                            )
                        )
                    }
                }

                if (mc.thePlayer != null && mc.thePlayer.ticksExisted <= 7) {
                    fakeLagDelay.reset()
                    packetBuffer.clear()
                }
            }

            "flying" -> {
                if (packet is C03PacketPlayer) {
                    val capabilities = PlayerCapabilities() // flags=2
                    capabilities.disableDamage = false
                    capabilities.isFlying = true
                    capabilities.allowFlying = false
                    capabilities.isCreativeMode = false
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                    debugMessage("Packet C13")
                }
            }

            "matrix" -> {
                if (packet is C03PacketPlayer && !(packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook)) {
                    event.cancelEvent()
                }
                if (packet is C02PacketUseEntity || packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook ||
                    packet is C06PacketPlayerPosLook || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
                    packet is C0APacketAnimation || packet is C0BPacketEntityAction
                ) {
                    event.cancelEvent()
                    packetBuffer.add(buffPacket)
                }
            }
            "hypixel" -> {
                Hypixel.onPacket(event)
            }
        }
    }

    @EventTarget
    fun onPreUpdate(event: PreUpdateEvent) {
        if (modeValue.equals("Hypixel")) Hypixel.onPreUpdate(event)
    }

    private fun debugMessage(str: String) {
        if (debug.get()) {
            alert(" [Disabler] $str")
        }
    }

    override val tag: String
        get() = modeValue.get()
}