package net.ccbluex.liquidbounce.features.module.modules.exploit.disabler

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.PreUpdateEvent
import net.ccbluex.liquidbounce.features.module.modules.exploit.Disabler
import net.ccbluex.liquidbounce.features.module.modules.exploit.DisablerX
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.features.module.modules.movement.Strafe
import net.ccbluex.liquidbounce.features.module.modules.movement.TargetStrafe
import net.ccbluex.liquidbounce.features.module.modules.world.Scaffold
import net.ccbluex.liquidbounce.utils.*
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacketNoEvent
import net.ccbluex.liquidbounce.utils.angle.Angle
import net.ccbluex.liquidbounce.utils.angle.AngleUtility
import net.minecraft.client.Minecraft
import net.minecraft.client.gui.inventory.GuiInventory
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.util.MathHelper
import java.util.*
import java.util.concurrent.CopyOnWriteArrayList


object Hypixel {
    private var hasDisabled = false
    private val clickWindowPackets = CopyOnWriteArrayList<C0EPacketClickWindow>()
    private var isCraftingItem = false
    private var timedOutTimer = TimeHelper()
    private var lastUid = 0
    private var cancelledPackets = 0

    private var angleUtility: AngleUtility = AngleUtility(110F, 120F, 30F, 40F)
    private var lastAngle: Angle? = null
    var yawDiff = 0f

    private var confirmTransactionQueue = LinkedList<Packet<INetHandlerPlayServer>>()
    private var keepAliveQueue = LinkedList<Packet<INetHandlerPlayServer>>()

    private val mc = Minecraft.getMinecraft()
    private val moduleManager = LiquidBounce.moduleManager
    private val disabler = moduleManager.getModule(DisablerX::class.java)

    private var lastRelease = TimeHelper()


    fun reset() {
        confirmTransactionQueue.clear()
        keepAliveQueue.clear()

        hasDisabled = false
        lastUid = 0
        cancelledPackets = 0

        clickWindowPackets.clear()
        isCraftingItem = false
    }

    fun onPacket(e: PacketEvent) {
        val packet = e.packet
        if (packet is S08PacketPlayerPosLook) {
            ClientUtils.displayAlert("S08: " + packet.x + " " + packet.y + " " + packet.z)
            if (!hasDisabled && mc.thePlayer.ticksExisted > 20) {
                e.cancelEvent()
                ClientUtils.displayAlert("Canceled S08")
            }
        }

        if (disabler!!.timerValue.get() && hasDisabled) {
            if (packet is C03PacketPlayer && !(packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook)) {
                cancelledPackets++
                e.cancelEvent()
            }
        }

        // Disabler
        when (packet) {
            is C0FPacketConfirmTransaction -> {
                processConfirmTransactionPacket(e)
            }
            is C00PacketKeepAlive -> {
                processKeepAlivePacket(e)
            }
            is C03PacketPlayer -> {
                processPlayerPosLooksPacket(e)
            }
        }
    }

    fun onPreUpdate(e: PreUpdateEvent) {
        if (mc.thePlayer.ticksExisted % 40 == 0) {
            val rate = (cancelledPackets / 40f * 100).toInt()
            ClientUtils.displayAlert("Movement Handler: $rate%")
            cancelledPackets = 0
        }
        if (MovementUtils.isMoving() && (moduleManager.getModule(Strafe::class.java)!!.state || moduleManager.getModule(
                Speed::class.java
            )!!.state)
        ) {
            if (!moduleManager.getModule(Scaffold::class.java)!!.state) {
                var targetYaw: Float = e.yaw
                if (TargetStrafe.canStrafe) {
                    targetYaw = RotationUtils.getRotations(LiquidBounce.combatManager.target).yaw
                } else {
                    if (mc.gameSettings.keyBindBack.pressed) {
                        targetYaw += 180f
                        if (mc.gameSettings.keyBindLeft.pressed) {
                            targetYaw += 45f
                        }
                        if (mc.gameSettings.keyBindRight.pressed) {
                            targetYaw -= 45f
                        }
                    } else if (mc.gameSettings.keyBindForward.pressed) {
                        if (mc.gameSettings.keyBindLeft.pressed) {
                            targetYaw -= 45f
                        }
                        if (mc.gameSettings.keyBindRight.pressed) {
                            targetYaw += 45f
                        }
                    } else {
                        if (mc.gameSettings.keyBindLeft.pressed) {
                            targetYaw -= 90f
                        }
                        if (mc.gameSettings.keyBindRight.pressed) {
                            targetYaw += 90f
                        }
                    }
                }
                val angle: Angle = angleUtility.smoothAngle(Angle(targetYaw, e.yaw), lastAngle, 120f, 360f)
                yawDiff = MathHelper.wrapAngleTo180_float(targetYaw - angle.yaw)
                e.yaw = angle.yaw
            }
        }
        lastAngle = Angle(e.yaw, e.pitch)
        if (hasDisabled) {
            if (confirmTransactionQueue.isEmpty()) {
                lastRelease.reset()
            } else {
                if (confirmTransactionQueue.size >= 6) {
                    while (!keepAliveQueue.isEmpty()) sendPacketNoEvent(keepAliveQueue.poll())
                    while (!confirmTransactionQueue.isEmpty()) {
                        val poll: Packet<INetHandlerPlayServer> = confirmTransactionQueue.poll()
                        sendPacketNoEvent(poll)
                    }
                }
            }
        }
    }

    private fun processConfirmTransactionPacket(e: PacketEvent) {
        val packet = e.packet as C0FPacketConfirmTransaction
        val windowId = packet.windowId
        val uid = packet.uid.toInt()
        if (windowId != 0 || uid >= 0) {
            ClientUtils.displayAlert("Inventory synchronized!")
        } else {
            if (uid == --lastUid) {
                if (!hasDisabled) {
                    ClientUtils.displayAlert("Watchdog disabled.")
                    hasDisabled = true
                }
                confirmTransactionQueue.offer(packet)
                e.cancelEvent()
            }
            lastUid = uid
        }
    }


    private fun processKeepAlivePacket(e: PacketEvent) {
        val packet = e.packet as C00PacketKeepAlive
        if (hasDisabled) {
            keepAliveQueue.offer(packet)
            e.cancelEvent()
        }
    }


    private fun processPlayerPosLooksPacket(e: PacketEvent) {
        if (!hasDisabled) {
            e.cancelEvent()
        }
    }
}